[{"categories":null,"content":"浅析 MVC MVC 三个对象分别做什么，给出伪代码示例 M（Model）：数据模型，负责数据及其相关的任务 const m = { data: {...}, methods: { 增、删、改、查... } ... } V（View）：视图，负责用户界面 const v = { element: xxx, template: yyy, render(data){ 渲染用户视图 } ... } C（Controller）：控制器，用于控制应用程序的流程，处理用户事件，组织调度M和V更新数据和视图 const c = { bindEvents(){ 绑定用户事件 } ... } EventBus 有哪些 API，是做什么用的，给出伪代码示例 eventBus是一个对象，它可以用来完成上述M、V、C对象间的通信。 eventsBus提供了on、off、trigger等方法，用来处理事件。 m = { data: {...}, methods: { ... update(data){ 修改m.data eventBus.trigger(A) } } } 表驱动编程是做什么的（可以自己查查资料） 表驱动法是一种编程模式——从表里查找信息而不是使用逻辑语句。 随着逻辑复杂性的增加，if/else 或switch中的代码将变得越来越肿，所以我们常说数据比程序逻辑更易驾驭。表驱动法就是将这些逻辑中的数据与逻辑分开，从而减少逻辑的复杂度 以一个月的天数为例，我们要写一串if/else 或者switch/case 来表达逻辑: if(1 == iMonth) {iDays = 31;} else if(2 == iMonth) {iDays = 28;} else if(3 == iMonth) {iDays = 31;} else if(4 == iMonth) {iDays = 30;} else if(5 == iMonth) {iDays = 31;} else if(6 == iMonth) {iDays = 30;} else if(7 == iMonth) {iDays = 31;} else if(8 == iMonth) {iDays = 31;} else if(9 == iMonth) {iDays = 30;} else if(10 == iMonth) {iDays = 31;} else if(11 == iMonth) {iDays = 30;} else if(12 == iMonth) {iDays = 31;} 但是我们把数据存到一张表里，就不需要冗余的逻辑了。 const month = { monthTable: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], get days(month, year) { // (year % 4 === 0) \u0026\u0026 (year % 100 !== 0 || year % 400 === 0) 闰年逻辑 return [month - 1]; } } 我是如何理解模块化的 将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起 块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信 可以随时修改某个模块的功能，不影响其他的模块 ","date":"2021-06-28","objectID":"/%E6%B5%85%E6%9E%90mvc/:0:0","tags":null,"title":"浅析MVC","uri":"/%E6%B5%85%E6%9E%90mvc/"},{"categories":null,"content":"Js常见面试题 什么是闭包？闭包的用途是什么？闭包的缺点是什么？ 闭包 如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包 function A(){ let a = 1 function B() = { console.log(a) } } 用途 一是常常用来’间接访问一个变量'，二是让这个变量的值始终保持在内存中。 缺点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值 call、apply、bind 的用法分别是什么？ call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。 function.call(thisArg, arg1, arg2, ...) apply() 方法调用一个具有给定this值的函数，以及以一个数组（或类数组对象）的形式提供的参数。 func.apply(thisArg, [argsArray]) bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 function.bind(thisArg[, arg1[, arg2[, ...]]]) 相同之处 改变函数体内 this 的指向。 不同之处 call、apply的区别：接受参数的方式不一样。 bind：不立即执行。而apply、call 立即执行。 请说出至少 10 个 HTTP 状态码，并描述各状态码的意义。 100 - 继续。客户端应继续其请求 200 - 请求成功。一般用于GET与POST请求 201 - 已创建。成功请求并创建了新的资源 202 - 已接受。已经接受请求，但未处理完成 301 - 资源（网页等）被永久转移到其它URL 302 - 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 404 - 请求的资源（网页等）不存在 405 - 客户端请求中的方法被禁止 406 - 服务器无法根据客户端请求的内容特性完成请求 500 - 内部服务器错误 502 - 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 如何实现数组去重？ 假设有数组 array = [1,5,2,3,4,2,3,1,3,4],你要写一个函数 unique，使得到的值为 unique(array) = [1,5,2,3,4]，也就是把重复的值都去掉，只保留不重复的值。 使用Set function unique(array){ return Array.from(new Set(array)) // 可简化return [...new Set(array)] } var array = [1,5,2,3,4,2,3,1,3,4] console.log(unique(array)) // [1,5,2,3,4] 对象不会去重，低版本浏览器不支持 不使用Set function unique(arr) { let map = new Map(); let array = []; // 数组用于返回结果 for (let i = 0; i \u003c arr.length; i++) { if(map.has(arr[i])) { // 如果有该key值 map.set(arr[i], true); } else { map.set(arr[i], false); // 如果没有该key值 array .push(arr[i]); } } return array ; } var array = [1,5,2,3,4,2,3,1,3,4] console.log(unique(array)) // [1,5,2,3,4] 对象不会去重，低版本浏览器不支持 DOM 事件相关,事件委托是什么，怎么阻止默认动作，怎么阻止事件冒泡？ 事件委托 利用事件冒泡的原理，让自己所触发的事件，让其父元素代替执行。 阻止默认动作 非IE浏览器：event.preventDefault() IE浏览器：window.event.returnValue = false function stopDefault(e) { //阻止默认浏览器动作(W3C) if (e \u0026\u0026 e.preventDefault) e.preventDefault(); //IE中阻止函数器默认动作的方式 else window.event.returnValue = false; return false; } 阻止事件冒泡 非IE浏览器：event.stopPropagation() IE浏览器：window.event.cancelBubble = true function stopBubble(e){ // 如果提供了事件对象，则是非IE浏览器下 if(e \u0026\u0026 e.stopPropagation){ // 因此它支持W3C的stopPropagation()方法 e.stopPropagation() }else{ // IE浏览器下，取消事件冒泡 window.event.cancelBubble = true } } 如何理解 JS 的继承？ 基于原型继承 function Parent(value){ this.val = value // 实例属性 } Parent.prototype.getValue = function(){ // 原型属性 console.log(this.val) } function Child(value){ Parent.call(this,value) // 借用构造函数来继承实例属性 } Child.prototype = new Parent() // 原型链继承 const child = new Child(1) child.getValue() // 1 child instancof Parent // true 基于class继承 class Parent{ constructor(value){ this.val = value } getValue(){ console.log(this.val) } } class Child extends Parent{ constructor(value){ super(value) } } let child = new Child(1) child.getValue() // 1 child instanceof Parent // true 给出正整数数组 array = [2,1,5,3,8,4,9,5]，请写出一个函数 sort，使得 sort(array) 得到从小到大排好序的数组 [1,2,3,4,5,5,8,9]，新的数组可以是在 array 自身上改的，也可以是完全新开辟的内存。（不得使用 JS 内置的 sort API） let min = (numbers) =\u003e { if (numbers.length \u003e 2) { return min( [numbers[0], min(numbers.slice(1))] ) } else { return Math.min.apply(null, numbers) } } let minIndex = (numbers) =\u003e{ return numbers.indexOf(min(numbers))} // 求出某个数字下标 let sort = (numbers) =\u003e { if (numbers.length \u003e 2) { let index = minIndex(numbers) console.log(`index:${index}`) let min = numbers[index] console.log(`min:${min}`) numbers.splice(index, 1) console.log(`numbers:${numbers}`) return [min].concat(sort(numbers)) } else { return numbers[0] \u003c numbers[1] ? numbers : numbers.reverse() } } array = [2,1,5,3,8,4,9,5] console.log(sort(array)) 你对 Promise 的了解？ Promise 的用途 Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 如何创建一个 new Promise return new Promise(((resolve, reject) =\u003e )) 如何使用 Promise.prototype.then then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。 const promise1 = new Promise((resolve, reject) =\u003e { resolve('Success!'); }); pr","date":"2021-06-23","objectID":"/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/:0:0","tags":null,"title":"Js常见面试题","uri":"/js%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":null,"content":"简述 DOM 事件模型 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:0:0","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"事件流 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:1:0","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"事件冒泡 事件冒泡是IE 的事件流，事件是由最具体的元素接收，然后逐级向上传播，在每一级的节点上都会发生，直到传播到document对象，向Chrome这样的浏览器会冒泡到window 对象（很容易记忆，联想水里的泡泡不也这样么）。 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:1:1","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"事件捕获 事件捕获是Netscape浏览器开发团队提出的，很有意思，他们思想和IE 的截然相反。也就是说，从不具体的节点到最具体的节点，一般是从document对象开始传播，不过很少人用事件捕获的，还是事件冒泡用的多。 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:1:2","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"DOM 事件流 这里规定的事件流有三个阶段： 事件捕获阶段，目标阶段，事件冒泡阶段。 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:1:3","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"先捕获还是先冒泡 2002年，w3c发布标准 文档名为DOM Level 2 Events Specification 规定浏览器应该同时支持两种调用顺序 首先按照grandfather-\u003efather-\u003eson 然后按照son-\u003efather-\u003egrandfather，开发者可以自己决定把fnYe放在捕捉阶段还是放在冒泡阶段 ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:1:4","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"事件委托 事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。 场景1: 要给100个按钮添加点击事件，咋办？答：监听这个100个按钮的祖先，等冒泡的时候判断target是不是这100个按钮中的一个 场景2: 你要监听目前不存在的元素的点击事件？ 答：监听祖先，等点击的时候看看是不是监听的元素即可。 优点：省监听数（内存），可以动态监听元素 封装一个事件委托 只要实行一个函数就可以实现事件委托要求：写出这样一个函数on('click','#testDiv','li',fn)当用户点击#testDiv里面的li元素时，调用fn函数要求用到事件委托 setTimeout(()=\u003e{ const button = document.createElement('button') button.textContent='click 1' div1.appendChild(button) },1000) on('click','#div1','button',()=\u003e{//'#div'是选择器不是元素 console.log('button 被点击啦') }) function on(eventType,element,selector,fn){ if(!(element instanceof Element)){ element = document.querySelector(element) } element.addEventListener(eventType,(e)=\u003e{ const t= e.target//被点击的元素 if(t.matches(selector)){//matches用来判断一个元素是否匹配一个选择器,selector是不是一个选择器 fn(e) } }) } ","date":"2021-06-07","objectID":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/:2:0","tags":null,"title":"DOM事件和事件委托","uri":"/dom%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"},{"categories":null,"content":"JQuery小结 jQuery 如何获取元素 元素选择器 jQuery 使用 CSS 选择器来选取 HTML 元素。 $(\"p\") 选取 \u003cp\u003e 元素。 $(\"p.intro\") 选取所有 class=“intro” 的 \u003cp\u003e 元素。 $(\"p#demo\") 选取所有 id=“demo” 的 \u003cp\u003e 元素。 属性选择器 $(\"[href]\") 选取所有带有 href 属性的元素。 $(\"[href='#']\") 选取所有带有 href 值等于 \"#\" 的元素。 $(\"[href!='#']\") 选取所有带有 href 值不等于 \"#\" 的元素。 $(\"[href$='.jpg']\") 选取所有 href 值以 \".jpg\" 结尾的元素。 jQuery 的链式操作是怎样的 选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如： $('div').find('h3').eq(2).html('Hello') 分解开来，就是下面这样： $('div') //找到div元素 　.find('h3') //选择其中的h3元素 　.eq(2) //选择第3个h3元素 　.html('Hello'); //将它的内容改为Hello jQuery 如何创建元素 .append() 在被选元素的结尾插入内容 .prepend() 在被选元素的开头插入内容 .after() 在被选元素之后插入内容 .before() 在被选元素之前插入内容 jQuery 如何修改元素的属性 .attr()获取匹配的元素集合中的第一个元素的属性的值。设置每一个匹配元素的一个或多个属性。 .prop()获取匹配的元素集中第一个元素的属性（property）值为匹配的元素设置一个或多个属性（properties）。 .removeAttr() 为匹配的元素集合中的每个元素中移除一个属性（attribute）。 .removeProp()为集合中匹配的元素删除一个属性（property）。 .val()获取匹配的元素集合中第一个元素的当前值。设置匹配的元素集合中每个元素的值。 ","date":"2021-06-07","objectID":"/jquery%E5%B0%8F%E7%BB%93/:0:0","tags":null,"title":"JQuery小结","uri":"/jquery%E5%B0%8F%E7%BB%93/"},{"categories":null,"content":"DOM编程 JS七种数据类型 number,string,bool,symbol,null,undefined,object JS五个falsy值 0,NaN,'',null,undefined DOM定义 含义：Document Object Model 文档对象模型；浏览器往window上加一个document，JS就可以操作网页 获取元素（element），也叫标签(tag) window.idXXX 或者 idXXX document.getElementById(‘idXXX’) document.getElementsByTagName(‘div’)[0] document.getElementsByClassName(‘red’)[0] document.querySelector('#idXXX') document.querySelectorAll('.red')[0] 获取待定元素 获取html元素：document.documentElement 获取head元素：document.head 获取body元素：document.body 获取窗口(窗口不是元素)：window 获取所有元素：document.all 节点Node 包括(常用): 1表示元素Element，也叫标签Tag 3表示文本 8表示注释Coment 9表示文档Dcument 11表示文档片段DocumentFragment cosole.dir(div)看原型链 第一层原型：HTMLDIVElement.prototype（这里包含div所有共有属性） 第二层原型：HTMLElement.prototype(这里面所有HTML标签共有属性) 第三层原型：Element.prototype(这里所有XML,HTML标签共有属性，不会以浏览器只能展示HTML) 第四场原型：Node.prototype(这里面所有节点共有属性，节点包括XML标签文本注释，HTML标签文本注释等) 第五层原型：EventTarget.prototype(里面最重要函数是addEventListener) 第六层原型：Object.prototype 节点增加 创建一个标签节点 1. let div1=document.createElement('div') 2. document.createElement('style') 3. document.creatElement('script') 4. document.createElement('li') 创建一个文本节点 text1=document.createTextNode('你好') 标签里面插入文本 div1.appendChild(text1) div1.innerText='你好' 或 div1.textContent='你好' *插入页面 创建标签默认处于JS线程中 必须把它插到head或者body立，才会生效 document.body.appendChild(div) 4.在已有页面中元素.appendChild(div) 节点的删除 两种方法： 旧方法：parentNode.childChild(childNode) 新方法：childNode.remove() //IE不支持 节点的改属性 写标准属性 1. 改class:div.className='red blue' 2. 改class:div.classList.add('red') 3. 改style:div.style='width:100px;color:blue' 4. 改style的一部分:div.style.width='200px' 5. 大小写：div.style.backgroundColor='white' 6. 改data-*属性：div.dataset.x='frank' 读标准属性 div.classList/a.href div.getAttribut('class')/a.getAttribut('href') 两种都可以用，但是值可能会稍微有点不同 改事件处理函数 div.onclick默认null 默认点击，div不会有任何事情发生 但如果把div.onclick改成一个函数fn 那么点击div的时候，浏览器就会调用这个函数 并且是这样被调用fn.call(div.event) div会被当成this event则包含了点击事件的所有信息，如坐标 div.addEventListener是div.onclick的升级 节点改内容 1.改文本内容 div.innerText='xxx' div.textContent='xxx' 2.改HTML内容 div.innerHTML='\u003cstrong\u003e重要内容\u003c/strong\u003e' 3.改标签 div.innerHTML='' //先清空 div.appendChild(div2) //再加内容 4.改爸爸 newParent.appendChild(div) 节点的查询 查爸爸 node.parentNode 或 node.parentElement 查爷爷 node.parentNode.parentNode 查子代 node.childNodes 或 node.children 查兄弟姐妹 node.parentNode.childNodes //排除自己 node.parentNode.children //排除自己 查老大 node.firstChild 或 node.children[0] 查老幺 node.lastChild 查看上一个哥哥/姐姐 node.previousSibling 查看下一个弟弟/妹妹(注意这里可能查到文本节点) node.nextSibling 遍历一个div里面所有的元素 travel = (node.fn)=\u003e{ fn(node) if(node.children){ for(let i=0;i\u003cnode.children.length;i++){ travel(node.children[1],fn) } } } travel(div1,(node)=\u003econsole.log(node)) 跨线程操作 属性同步 标准属性 对div1的标准属性修改，会被浏览器同步到页面中 比如id,className,title等 data-*属性 启示：如果有自定义属性，想被同步到页面中，请使用data-作为前缀 Property 与 Attribute property属性：JS线程中div1的所有属性，叫做div1的property Attribut属性：渲染引擎中div1对应标签的属性，叫做attribute 区别：大部分时候，两者的值是相等的；但如果不是标准属性，那么它们一开始时相等，但attribute只支持字符串，而property支持字符串，布尔等类型 注意 1.假设页面中有如下元素 \u003cdiv id=\"test\" class=\"red\"\u003edemo\u003c/div\u003e 获取该 div 元素的代码: document.getElementById(‘test’) document.getElementsByClassName(‘red’)[0] window.test document.querySelector('#test') document.querySelectorAll('#test')[0] 2.关于节点(Node) 、元素(Element)、标签(Tag) 的关系描述: 节点包括元素和文本等 元素就是标签，叫法不同而已 3.要删除一个节点 x x.parentNode.removeChild(x) x.remove() 4.获取 x 元素的 class 属性 x.className x.getAttribute(‘class’) 5.将 div 的宽度设置为 100 像素 div.style.width = ‘100px’ 6.关于以下代码，下列说法正确 div.onclick = function(){ console.log(this) console.log(arguments[0]) } 当用户点击该 div 时，该代码中的 this 是 div 当用户点击该 div 时，arguments[0] 是事件相关的信息组成的对象 ","date":"2021-06-04","objectID":"/dom/:0:0","tags":null,"title":"DOM","uri":"/dom/"},{"categories":null,"content":"JS 函数的执行时机 解释为什么如下代码会打印 6 个 6 let i = 0 for(i = 0; i\u003c6; i++){ setTimeout(()=\u003e{ console.log(i) },0) } 因为setTimeout是一个异步任务，执行到这里的操作会被浏览器丢到另一个任务队列里去，浏览器这时候会继续往下执行，把下面的代码都执行完了才会来执行setTimeout函数里的操作， 这时候因为for循环已经把i加到6了，所以输出的全部都是6。 写出让上面代码打印 0、1、2、3、4、5 的方法 for(let i = 0; i\u003c6; i++){ setTimeout(()=\u003e{ console.log(i) },0) } 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5 let i for(i = 0; i\u003c6; i++){ const x = i setTimeout(()=\u003e{ console.log(x) }) } let i for(i = 0; i\u003c6; i++){ setTimeout((value)=\u003e{ console.log(value) },0,i) } ","date":"2021-05-28","objectID":"/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/:0:0","tags":null,"title":"JS函数的执行时机","uri":"/js%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"},{"categories":null,"content":"JS对象基本用法 声明对象的两种语法 let obj ={} let obj = new Object({}) 如何删除对象的属性 delete obj.xxx或delete obj['xxx'] 如何查看对象的属性 查看自身所有属性 Object.keys(obj) 查看自身+共有熟悉 console.dir(obj) 或者自己依次用Object.keys打印出obj.__proto__ 判断一个属性是自身的还是共有的 obj.hashOwnProperty('toString') 如何修改或增加对象的属性 修改自身直接赋值 obj['name']='jack' 修改自身批量赋值 Object.assign(obj,{age:18,gender:'man'}) 修改共有熟悉 Object.prototype.toString = 'xxx' 修改隐藏属性 Object.create(common) ‘name’ in obj和obj.hasOwnProperty(‘name’) 的区别 前者不光检测当前对象，还会检测当前对象原型链中是否具有这个属性，后者只在当前对象自身上检测。 ","date":"2021-05-23","objectID":"/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/:0:0","tags":null,"title":"JS对象基本用法","uri":"/js%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"},{"categories":null,"content":"JS基本语法 什么是表达式和语句 表达式 1 + 2表达式的值为3 语句 let a = 1是一个语句 二者的区别 表达式一般都有值，语句可能有也有可能没有 语句一般会改变环境（声明、赋值） 上面两句话不是绝对的 标识符的规则 第一个字符，可以是 Unicode 字母或 $ 或 _ 或中文 后面的字符，除了上面所说，还可以有数字 if else 语句 语法 If(表达式){语句1}else{语法2} {}在语句只有一句的时候可以省略 变态情况 表达式里可以非常变态，如a = 1 语句1里可以非常变态，如嵌套的 if else 语句2里可以非常变态，如嵌套的 if else 锁进也可以很变态，如面试题常常下套 a = 1 if (a === 2) console.log('a') console.log('a等于2') 最推荐使用的写法 if (表达式) { 语句 } else if (表达式）{ 语句 } else { 语句 } while for 语句 语法 while (表达式) {语句} 判断表达式的真假 语法糖 for 是 while 循环的方便写法 语法 for(语句1；表达式2；语句3){ ​ 循环体 } 先执行语句1 然后判断表达式2 如果为真，执行循环体，然后执行语句3 如果为假，直接退出循环，执行后面的语句 break continue break 跳出代码块或循环 var i = 0 ; while(i \u003c 100) { console.log('i 当前为：' + i); i++; if (i === 10) break; } 上面代码只会执行10次循环，一旦 i 等于10，就会跳出循环 continue 用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 var i = 0; while (i \u003c 100){ i++; if (i % 2 === 0) continue; console.log('i 当前为：' + i); } 上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环。 如果存在多重循环，不带参数的break语句和continue语句都只针对最内层循环。 label 语法 JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置。 标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 标签通常与break语句和continue语句配合使用，跳出特定的循环。 foo : { console.log(1); break foo; console.log('本行不会输出') } console.log(2); 上面的代码在 break 命令后面加了 foo 标签，直接跳出代码块（也可以跳出循环）。 面试 { foo:1 } ","date":"2021-05-21","objectID":"/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":null,"title":"JS基本语法","uri":"/js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"JavaScript 的诞生 1994年，网景发布了浏览器，在当时轰动一时。但是，此时它还不具备与访问者交互的能力。网景公司急需一门网页脚本语言，使得浏览器可以与网页交互。当时有两种选择可供参考，但是一直没下定决心。 直到1995年 Sun 公司的 Java 正式推出。由于 Java 一次编写，到处运行的优势，使得网景公司决定与之合作。 此时 Javascript 之父登场了，Brendan Eich 被网景公司录用，只花了10多天就把 Javascript 设计出来了。由于时间过短，此时还存在很多不严谨的地方。 微软公司于1995年首次推出 Internet Explorer，从而引发了与 Netscape 的浏览器大战。微软对 Netscape Navigator 解释器进行了逆向工程，创建了 JScript 。 1996年11月，网景正式向 ECMA 提交语言标准。1997年6月，ECMA 以JavaScript语言为基础制定了 ECMAScript 标准规范 ECMA-262。JavaScript 成为了 ECMAScrip t最著名的实现之一。 ","date":"2021-05-18","objectID":"/javascript/:0:0","tags":null,"title":"JavaScript","uri":"/javascript/"},{"categories":null,"content":"浅析url URL 包含哪几部分，每部分分别有什么作用 协议：规定www服务器与浏览器之间信息传输规范的标准 域名（IP）：如何定位一台设备 端口（用于区分一台主机上不同服务的号码 路径：用于请求到不同页面 查询参数：用于显示同一页面不同内容 锚点：用于定位同一页面不同位置 DNS 的作用是什么，nslookup 命令怎么用 dns的作用是查询一个域名对应的IP地址 nslookup baidu.com IP 的作用是什么，ping 命令怎么用 IP是Internet Protocol（网际互连协议）的缩写，是TCP/IP体系中的网际层协议。设计IP的目的是提高网络的可扩展性：一是解决互联网问题，实现大规模、异构网络的互联互通；二是分割顶层网络应用和底层网络技术之间的耦合关系，以利于两者的独立发展。根据端到端的设计原则，IP只为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务。 ping baidu.com 域名是什么，分别哪几类域名 域名就是对ip的别称 一级域名、二级域名、三级域名 ","date":"2021-05-17","objectID":"/%E6%B5%85%E6%9E%90url/:0:0","tags":null,"title":"浅析url","uri":"/%E6%B5%85%E6%9E%90url/"},{"categories":null,"content":"CSS知识总结 浏览器渲染原理 根据HTML构建HTML树（DOM） 根据CSS构建CSS树（CSSOM） 将两棵树合并成一颗渲染树（render tree) layout布局（文档流、盒模型、计算大小和位置） Paint绘制（把边框颜色、文字颜色、阴影等画出来） Compose合成（根据层叠关系展示画面） CSS 动画的两种做法（transition 和 animation） 使用两次transform，配合transition过渡 使用animation 声明关键帧 添加动画 总结 css动画建议用animation，想要制作出好看的动画想象力必不可少，掌握常用属性，多次尝试，达到理想效果。 ","date":"2021-05-17","objectID":"/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"CSS知识总结","uri":"/css%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"css盒模型 完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。为了增加一些额外的复杂性，有一个标准的和替代（IE）的盒模型。 ","date":"2021-05-15","objectID":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/:0:0","tags":null,"title":"Css盒模型","uri":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"categories":null,"content":"盒模型的各个部分 CSS中组成一个块级盒子需要: Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height. Padding box: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。 Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。 Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。 ","date":"2021-05-15","objectID":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/:0:1","tags":null,"title":"Css盒模型","uri":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"categories":null,"content":"标准盒模型 在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。 见下图。 假设定义了 width, height, margin, border, and padding: .box { width: 350px; height: 150px; margin: 25px; padding: 25px; border: 5px solid black; } 如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。 ","date":"2021-05-15","objectID":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/:0:2","tags":null,"title":"Css盒模型","uri":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"categories":null,"content":"替代（IE）盒模型 你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦，而且你的想法是对的! 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到 (width = 350px, height = 150px). 默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。 这样就可以告诉浏览器使用 border-box 来定义区域，从而设定您想要的大小。 .box { box-sizing: border-box; } ","date":"2021-05-15","objectID":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/:0:3","tags":null,"title":"Css盒模型","uri":"/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"},{"categories":null,"content":"Html入门笔记3 ","date":"2021-05-13","objectID":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03/:0:0","tags":null,"title":"Html入门笔记3","uri":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03/"},{"categories":null,"content":"#Html入门笔记2 ","date":"2021-05-13","objectID":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/:0:0","tags":null,"title":"Html入门笔记2","uri":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02/"},{"categories":null,"content":"常用标签 a标签的用法 HTML \u003ca\u003e 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。\u003ca\u003e 中的内容应该应该指明链接的意图。如果存在href 属性，当 \u003ca\u003e 元素聚焦时按下回车键就会激活它。 \u003ca href=\"\"\u003e\u003c/a\u003e img标签的用法 HTML \u003cimg\u003e 元素将一份图像嵌入文档。 \u003cimg src=\"\" alt=\"\"\u003e src 属性是必须的，它包含了你想嵌入的图片的文件路径。 alt 属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它难以置信地有用——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时 table标签的用法 HTML的 table 元素表示表格数据 — 即通过二维数据表表示的信息。 \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eThe table header\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003eThe table body\u003c/td\u003e \u003ctd\u003ewith two columns\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 其他感想 标签可用的属性很多，但常用的就那几个。 ","date":"2021-05-12","objectID":"/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/:0:0","tags":null,"title":"Html常用标签","uri":"/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"},{"categories":null,"content":" HTML 是谁发明的 李爵士 HTML 起手应该写什么 ···\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003cstyle\u003e \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e\u003c/div\u003e \u003cdiv\u003e\u003c/div\u003e \u003c/body\u003e ···\u003c/html\u003e 常用的表章节的标签有哪些，分别是什么意思（h1~h6、section、article、main、aside 等等） h1-h6 标题 section 章节 article 文章 p 段落 header 头部 footer 脚部 main 主要内容 aside 旁支内容 div 划分 全局属性有哪些 class、contenteditable、hidden、id、style、tabindex、title 常用的内容标签有哪些，分别是什么意思（a、strong、em、code、pre 等等） ol li(ordered list+list item) ul li(unordered list + list item) dl dt dd(description list + term +data) pre (preview) hr br(break) a(anchor) em(emphasis) strong code blockquote q(quoto) ","date":"2021-05-11","objectID":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/:0:0","tags":null,"title":"HTML入门笔记1","uri":"/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/"}]